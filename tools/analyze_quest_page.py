#!/usr/bin/env python3
"""
Quest System Analysis Script

Este script analisa a p√°gina de quests do SimpleMMO para extrair:
1. Estrutura HTML da p√°gina
2. Elementos dos Quest Points
3. Lista de quests dispon√≠veis
4. Estrutura dos popups de quest
5. Bot√µes e elementos de intera√ß√£o

Execute este script para coletar informa√ß√µes antes de implementar o sistema de quests.
"""

import asyncio
import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

async def analyze_quest_page():
    """Analisa a p√°gina de quests do SimpleMMO"""

    print("üîç Analisando p√°gina de quests do SimpleMMO...")

    try:
        from automation.web_engine import WebEngineManager

        # Get web engine
        engine = await WebEngineManager.get_instance()
        page = await engine.get_page()

        if not page:
            print("‚ùå N√£o foi poss√≠vel obter a p√°gina")
            return False

        print(f"‚úÖ P√°gina atual: {page.url}")

        # Navigate to quests page
        print("\nüìç Navegando para a p√°gina de quests...")
        await page.goto("https://web.simple-mmo.com/quests")
        await page.wait_for_load_state("networkidle")
        print(f"‚úÖ Navega√ß√£o completa: {page.url}")

        print("\n" + "="*80)
        print("üìã AN√ÅLISE DA P√ÅGINA DE QUESTS")
        print("="*80)

        # Criar lista para armazenar todas as informa√ß√µes
        analysis_report = []
        analysis_report.append("QUEST PAGE ANALYSIS REPORT")
        analysis_report.append("="*80)
        analysis_report.append(f"Timestamp: {asyncio.get_event_loop().time()}")
        analysis_report.append(f"URL: {page.url}")
        analysis_report.append("")

        # 1. An√°lise dos Quest Points
        print("\nüéØ 1. ANALISANDO QUEST POINTS...")
        analysis_report.append("üéØ 1. QUEST POINTS ANALYSIS")
        analysis_report.append("-" * 40)

        # Procurar por elementos que contenham "Quest Points" ou similar
        quest_points_elements = await page.query_selector_all("*")

        # Salvar HTML completo da p√°gina
        html_content = await page.content()

        # Procurar por Quest Points no HTML
        lines = html_content.split('\n')
        quest_points_lines = [line.strip() for line in lines if 'quest' in line.lower() and 'point' in line.lower()]

        if quest_points_lines:
            print("üìä Linhas HTML relacionadas a Quest Points:")
            analysis_report.append("üìä HTML lines related to Quest Points:")
            for i, line in enumerate(quest_points_lines[:10]):  # Salvar mais linhas no arquivo
                print(f"   {i+1}. {line}")
                analysis_report.append(f"   {i+1}. {line}")

        # Procurar por n√∫meros que podem ser quest points
        try:
            # Tentar encontrar elementos com n√∫meros que podem ser quest points
            possible_quest_elements = await page.query_selector_all("span, div, p")

            print("\nüî¢ Procurando por elementos com n√∫meros (poss√≠veis Quest Points):")
            analysis_report.append("\nüî¢ Elements with numbers (possible Quest Points):")
            number_elements_found = 0
            for element in possible_quest_elements[:30]:  # Aumentar limite no arquivo
                try:
                    text = await element.text_content()
                    if text and any(char.isdigit() for char in text) and len(text.strip()) < 20:
                        element_info = f"   - '{text.strip()}'"
                        print(element_info)
                        analysis_report.append(element_info)
                        number_elements_found += 1
                except:
                    continue
            analysis_report.append(f"Total number elements found: {number_elements_found}")
        except Exception as e:
            error_msg = f"‚ö†Ô∏è Erro ao procurar elementos: {e}"
            print(error_msg)
            analysis_report.append(error_msg)

        # 2. An√°lise da se√ß√£o "Not Completed"
        print("\nüìù 2. ANALISANDO SE√á√ÉO 'NOT COMPLETED'...")
        analysis_report.append("\nüìù 2. 'NOT COMPLETED' SECTION ANALYSIS")
        analysis_report.append("-" * 40)

        # Procurar por texto "Not Completed" ou similar
        not_completed_text = await page.query_selector_all("text=Not Completed, text=not completed, text=Not completed")

        if not not_completed_text:
            # Procurar por outros termos relacionados
            tabs_or_sections = await page.query_selector_all("a, button, div, span")

            print("üîç Procurando por abas ou se√ß√µes relacionadas a quests:")
            analysis_report.append("üîç Tabs or sections related to quests:")
            for element in tabs_or_sections[:50]:  # Aumentar limite no arquivo
                try:
                    text = await element.text_content()
                    if text and any(keyword in text.lower() for keyword in ['completed', 'available', 'quest', 'tab']):
                        tag_name = await element.evaluate("el => el.tagName")
                        class_name = await element.get_attribute("class") or ""
                        element_info = f"   - {tag_name}: '{text.strip()}' (class: {class_name})"
                        print(element_info)
                        analysis_report.append(element_info)
                except:
                    continue

        # 3. An√°lise da lista de quests
        print("\nüóíÔ∏è 3. ANALISANDO LISTA DE QUESTS...")
        analysis_report.append("\nüóíÔ∏è 3. QUEST LIST ANALYSIS")
        analysis_report.append("-" * 40)

        # Procurar por elementos que podem ser quests
        quest_items = await page.query_selector_all("div, li, tr")

        print("üîç Procurando por itens de quest (elementos com informa√ß√µes estruturadas):")
        analysis_report.append("üîç Quest items (structured information elements):")
        quest_count = 0
        for element in quest_items[:100]:  # Aumentar limite no arquivo
            try:
                text = await element.text_content()
                if text and len(text.strip()) > 10 and len(text.strip()) < 200:
                    # Verificar se cont√©m palavras relacionadas a quest
                    if any(keyword in text.lower() for keyword in ['level', 'left', 'quest', 'perform']):
                        quest_info = f"   Quest {quest_count + 1}: '{text.strip()[:150]}...'"
                        print(quest_info)
                        analysis_report.append(quest_info)
                        quest_count += 1
                        if quest_count >= 10:  # Salvar mais exemplos no arquivo
                            break
            except:
                continue

        analysis_report.append(f"Total quest items found: {quest_count}")

        # 4. Salvar todos os arquivos de an√°lise
        print(f"\nüíæ 4. SALVANDO ARQUIVOS DE AN√ÅLISE...")

        # Salvar relat√≥rio de an√°lise
        analysis_text = "\n".join(analysis_report)
        with open("quest_page_analysis.txt", "w", encoding="utf-8") as f:
            f.write(analysis_text)
        print(f"‚úÖ Relat√≥rio de an√°lise salvo em: quest_page_analysis.txt")

        # Salvar HTML da p√°gina
        with open("quest_page_structure.html", "w", encoding="utf-8") as f:
            f.write(html_content)
        print(f"‚úÖ HTML completo salvo em: quest_page_structure.html")

        # Salvar estrutura simplificada com mais detalhes
        with open("quest_page_elements.txt", "w", encoding="utf-8") as f:
            f.write("=== AN√ÅLISE DETALHADA DOS ELEMENTOS ===\n\n")
            f.write(f"URL: {page.url}\n")
            f.write(f"T√≠tulo: {await page.title()}\n\n")

            f.write("=== TODOS OS BOT√ïES ===\n")
            buttons = await page.query_selector_all("button, input[type='button'], input[type='submit']")
            for i, button in enumerate(buttons):
                try:
                    text = await button.text_content()
                    classes = await button.get_attribute("class") or ""
                    f.write(f"Button {i+1}: '{text.strip()}' (class: {classes})\n")
                except:
                    f.write(f"Button {i+1}: [erro ao ler]\n")

            f.write("\n=== TODOS OS LINKS ===\n")
            links = await page.query_selector_all("a")
            for i, link in enumerate(links[:20]):  # Limitar a 20 links
                try:
                    text = await link.text_content()
                    href = await link.get_attribute("href") or ""
                    classes = await link.get_attribute("class") or ""
                    f.write(f"Link {i+1}: '{text.strip()}' -> {href} (class: {classes})\n")
                except:
                    f.write(f"Link {i+1}: [erro ao ler]\n")

            f.write("\n=== ELEMENTOS COM N√öMEROS ===\n")
            all_elements = await page.query_selector_all("span, div, p, td")
            number_count = 0
            for element in all_elements:
                try:
                    text = await element.text_content()
                    if text and any(char.isdigit() for char in text) and len(text.strip()) < 50:
                        tag_name = await element.evaluate("el => el.tagName")
                        classes = await element.get_attribute("class") or ""
                        f.write(f"N√∫mero {number_count+1}: {tag_name} '{text.strip()}' (class: {classes})\n")
                        number_count += 1
                        if number_count >= 50:  # Limitar output
                            break
                except:
                    continue

        print(f"‚úÖ Elementos detalhados salvos em: quest_page_elements.txt")
                    if text and text.strip():
                        f.write(f"{tag_name}: {text.strip()}\n")
                except:
                    continue

        print(f"‚úÖ Estrutura salva em: quest_page_structure.txt")

        # 5. Testar cliques em elementos
        print(f"\nüñ±Ô∏è 5. TESTANDO ELEMENTOS CLIC√ÅVEIS...")

        # Procurar por bot√µes e links
        clickable_elements = await page.query_selector_all("button, a, [role='button'], [onclick]")

        print(f"üîç Encontrados {len(clickable_elements)} elementos clic√°veis:")
        for i, element in enumerate(clickable_elements[:10]):  # Mostrar apenas 10
            try:
                text = await element.text_content()
                tag_name = await element.evaluate("el => el.tagName")
                if text and text.strip():
                    print(f"   {i+1}. {tag_name}: '{text.strip()}'")
            except:
                continue

        print("\n" + "="*80)
        print("‚úÖ AN√ÅLISE COMPLETA!")
        print("="*80)
        print("üìã Arquivos gerados:")
        print("   - quest_page_analysis.html (HTML completo)")
        print("   - quest_page_structure.txt (estrutura resumida)")
        print("\nüí° Pr√≥ximos passos:")
        print("   1. Revisar os arquivos gerados")
        print("   2. Identificar seletores CSS espec√≠ficos")
        print("   3. Testar intera√ß√µes com elementos")

        return True

    except Exception as e:
        print(f"‚ùå Erro durante an√°lise: {e}")
        import traceback
        traceback.print_exc()
        return False

async def main():
    """Fun√ß√£o principal"""
    try:
        success = await analyze_quest_page()
        if success:
            print("\nüéâ An√°lise conclu√≠da com sucesso!")
        else:
            print("\n‚ùå An√°lise falhou!")
    except Exception as e:
        print(f"\n‚ùå Erro: {e}")
    finally:
        try:
            from automation.web_engine import WebEngineManager
            # N√£o fazer force_reset para manter a p√°gina aberta para inspe√ß√£o manual
            print("\nüí° P√°gina mantida aberta para inspe√ß√£o manual")
        except:
            pass

if __name__ == "__main__":
    asyncio.run(main())
